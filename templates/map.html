{% extends "base.html" %}
{% block content %}
<div class="search-layout">
  <aside class="p-3">
    <div class="section-heading">Search Options</div>
    <div id="statusBanner" class="alert alert-info d-none"></div>

    <div class="control-block">
      <label class="section-heading mb-2">Mode</label>
      <div class="btn-group w-100">
        <button type="button" class="btn btn-outline-primary active" data-mode="nearest">Nearby</button>
        <button type="button" class="btn btn-outline-primary" data-mode="radius">Radius</button>
      </div>
    </div>

    <div class="control-block">
      <label class="section-heading mb-2">Search</label>
      <input id="searchInput" type="search" class="form-control" placeholder="Search amenities">
    </div>

    <div class="control-block">
      <label class="section-heading mb-2">Categories</label>
      <div id="categoryChips" class="d-flex flex-wrap gap-2">
        <button class="btn btn-chip" data-category="all">All</button>
        <button class="btn btn-chip" data-category="cafe">Cafés</button>
        <button class="btn btn-chip" data-category="shop">Shops</button>
        <button class="btn btn-chip" data-category="gym">Gyms</button>
        <button class="btn btn-chip" data-category="atm">ATMs</button>
        <button class="btn btn-chip" data-category="park">Parks</button>
      </div>
    </div>



    <div class="control-block d-none" id="radiusControls">
      <label class="section-heading mb-2">Radius (km)</label>
      <input id="radiusKm" type="range" min="0.2" max="5" step="0.1" value="1.0" class="form-range">
      <div class="d-flex justify-content-between text-muted small">
        <span>0.2</span>
        <span id="radiusValue">1.0 km</span>
        <span>5</span>
      </div>
    </div>

    <div class="control-block">
      <label class="section-heading mb-2">Select Area</label>
      <select id="areaSelect" class="form-select">
        <option value="">Choose an area</option>
      </select>
    </div>

    <div class="d-grid gap-2">
      <button id="locateMe" class="btn btn-primary">Use my location</button>
      <button id="resetView" class="btn btn-outline-secondary">Reset view</button>
      <button id="btnClearRoutes" class="btn btn-outline-secondary">Clear routes</button>
    </div>
  </aside>

  <section class="p-3">
    <div class="mb-3">
      <div id="map"></div>
    </div>
    <div class="p-3 bg-white border rounded">
      <div class="d-flex justify-content-between mb-3">
        <div>
          <strong>Results</strong>
          <div class="text-muted small" id="resultSummary">Click the map to explore.</div>
        </div>
        <div id="loadingIndicator" class="spinner-border spinner-border-sm d-none"></div>
      </div>
      <div id="resultsList"></div>
    </div>
  </section>
</div>

<script>
window.addEventListener("DOMContentLoaded", function() {
  // check if browser supports geolocation
  if (!("geolocation" in navigator)) {
    document.body.classList.add("no-geolocation-support");
  }
  
  function initMap() {
    // wait for leaflet to load before initializing
    if (typeof L === "undefined") {
      setTimeout(initMap, 100);
      return;
    }

    // create map centered on dublin city center
    const map = L.map("map", {
      scrollWheelZoom: true,
      zoomControl: true,
    }).setView([53.3498, -6.2603], 13);

    // add openstreetmap tile layer
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: "© OpenStreetMap contributors",
      maxZoom: 19,
    }).addTo(map);

    // cache icons so we dont create the same one multiple times
    const amenityIconCache = new Map();
    const amenityIconSlugs = new Set(["cafe", "shop", "gym", "atm", "park", "default"]);
    function categoryToSlug(category) {
      if (!category) return "default";
      return amenityIconSlugs.has(category) ? category : "default";
    }
    function createAmenityIcon(category) {
      const slug = categoryToSlug(category);
      if (!amenityIconCache.has(slug)) {
        const iconUrl = `/static/img/pin-${slug}.svg`;
        amenityIconCache.set(slug, L.icon({
          iconUrl,
          iconSize: [36, 44],
          iconAnchor: [18, 42],
          popupAnchor: [0, -38],
        }));
      }
      return amenityIconCache.get(slug);
    }
    function getAmenityIcon(category) {
      return createAmenityIcon(category);
    }

    const userIcon = L.icon({
      iconUrl: "/static/img/mac-location.svg",
      iconSize: [36, 36],
      iconAnchor: [18, 18],
    });

    const radiusIcon = L.divIcon({
      className: "radius-pin-icon",
      html: "<span></span>",
      iconSize: [18, 18],
      iconAnchor: [9, 9],
    });

    let userMarker = null;
    let userAccuracyCircle = null;
    let radiusMarker = null;
    let radiusCircle = null;

    const amenityLayerIndex = new Map();

    // main layer for displaying amenity points with custom icons
    const amenitiesLayer = L.geoJSON(null, {
      pointToLayer: (feature, latlng) => {
        const category = feature?.properties?.category;
        return L.marker(latlng, {
          icon: getAmenityIcon(category),
          riseOnHover: true,
        });
      },
      onEachFeature: (feature, layer) => {
        const popupHTML = buildPopupContent(feature);
        layer.bindPopup(popupHTML);
        // store in index so we can find and focus on markers later
        amenityLayerIndex.set(String(feature.id), layer);
      },
    }).addTo(map);

    const areasLayer = L.geoJSON(null, {
      style: { color: "#4c6ef5", weight: 2, fillOpacity: 0.08 },
      onEachFeature: (feature, layer) => {
        const name = feature.properties?.name || "Area";
        layer.bindPopup(`<strong>${name}</strong>`);
      },
      interactive: false,
    }).addTo(map);

    const routesLayer = L.geoJSON(null, {
      style: { color: "#20c997", weight: 3 },
      onEachFeature: (feature, layer) => {
        const name = feature.properties?.name || "Route";
        layer.bindPopup(`<strong>${name}</strong><br/><small>Click to view route details</small>`);
      },
    }).addTo(map);

    const statusBanner = document.getElementById("statusBanner");
    const resultsList = document.getElementById("resultsList");
    const loadingIndicator = document.getElementById("loadingIndicator");
    const radiusInput = document.getElementById("radiusKm");
    const radiusValue = document.getElementById("radiusValue");
    const modeButtons = document.querySelectorAll(".btn-group .btn[data-mode]");
    const searchInput = document.getElementById("searchInput");
    const categoryChips = Array.from(document.querySelectorAll("#categoryChips .btn-chip"));
    const areaSelect = document.getElementById("areaSelect");
    const radiusSection = document.getElementById("radiusControls");
    const resultSummary = document.getElementById("resultSummary");
    const locateButton = document.getElementById("locateMe");
    let searchDebounce = null;

    // app state object - centralized state management
    const state = {
      mode: "nearest",
      selectedCategories: new Set(),
      searchTerm: "",
      areaId: null,
      userLocation: null,
      lastOrigin: {
        nearest: null,
        radius: null,
      },
    };

    function updateCategoryChipsUI() {
      categoryChips.forEach(chip => {
        const cat = chip.dataset.category;
        if (cat === "all") {
          chip.classList.toggle("active", state.selectedCategories.size === 0);
        } else {
          chip.classList.toggle("active", state.selectedCategories.has(cat));
        }
      });
    }

    function setStatus(message, variant = "info", sticky = false) {
      statusBanner.textContent = message;
      statusBanner.className = `alert alert-${variant} status-banner`;
      if (!message) {
        statusBanner.classList.add("d-none");
        return;
      }
      statusBanner.classList.remove("d-none");
      if (!sticky) {
        setTimeout(() => statusBanner.classList.add("d-none"), 4000);
      }
    }

    function setLoading(isLoading) {
      loadingIndicator.classList.toggle("d-none", !isLoading);
    }

    function rememberOrigin(mode, latlng, remember) {
      if (!remember) return;
      if (mode === "nearest") {
        state.lastOrigin.nearest = latlng;
      } else if (mode === "radius") {
        state.lastOrigin.radius = latlng;
      }
    }

    function parseDescription(description) {
      // try to parse description as json if its a string otherwise return empty object
      if (!description) return {};
      if (typeof description === "object" && description !== null) return description;
      try {
        const parsed = JSON.parse(description);
        return parsed && typeof parsed === "object" ? parsed : {};
      } catch (error) {
        return description ? { note: description } : {};
      }
    }

    function extractDetails(feature) {
      // get structured details from either the details field or description field
      const explicit = feature?.properties?.details;
      if (explicit && typeof explicit === "object") {
        return explicit;
      }
      return parseDescription(feature?.properties?.description);
    }

    function buildDetailLines(details = {}, category) {
      const lines = [];
      const address = formatAddress(details);
      if (address) lines.push(`On ${address}`);
      if (details.operator || details.brand) {
        lines.push([details.operator, details.brand].filter(Boolean).join(" · "));
      }
      if (details.cuisine && category === "cafe") lines.push(`Cuisine: ${details.cuisine}`);
      if (details.opening_hours) lines.push(`Hours: ${details.opening_hours}`);
      if (details.website) lines.push(details.website);
      if (details.phone) lines.push(`Phone: ${details.phone}`);
      if (details.note) lines.push(details.note);
      return lines;
    }
    window.buildDetailLines = buildDetailLines;

    function formatDistance(distanceMeters) {
      if (distanceMeters === null || distanceMeters === undefined) return null;
      const meters = Number(distanceMeters);
      if (!Number.isFinite(meters)) return null;
      if (meters >= 1000) {
        const km = meters / 1000;
        return `${km.toFixed(km < 10 ? 1 : 0)} km`;
      }
      if (meters < 50) {
        return "<50 m";
      }
      return `${Math.round(meters)} m`;
    }

    function formatAddress(details) {
      const parts = [];
      if (details.housenumber) parts.push(details.housenumber);
      if (details.street) parts.push(details.street);
      return parts.join(" ");
    }

    function buildPopupContent(feature) {
      const props = feature.properties || {};
      const details = extractDetails(feature);
      const address = formatAddress(details);
      const lines = [];

      if (address) lines.push(`Address: ${address}`);
      if (details.opening_hours) lines.push(`Hours: ${details.opening_hours}`);
      if (details.cuisine) lines.push(`Cuisine: ${details.cuisine}`);

      const operatorParts = [details.operator, details.brand].filter(Boolean);
      if (operatorParts.length) lines.push(`Operator: ${operatorParts.join(" · ")}`);

      if (details.phone) lines.push(`Phone: ${details.phone}`);
      if (details.website) {
        lines.push(`<a href="${details.website}" target="_blank" rel="noopener">Website</a>`);
      }
      if (details.note) lines.push(details.note);

      const detailHTML = lines.length ? `<div class="small mt-2">${lines.join("<br/>")}</div>` : "";
      return `
        <div class="fw-semibold text-primary">${props.name || "Amenity"}</div>
        <div class="text-muted small text-uppercase">${(props.category || "Amenity").toUpperCase()}</div>
        ${detailHTML}
      `;
    }

    function updateRadiusOverlay(latlng, km) {
      // show a circle on the map to visualize the search radius
      const radiusMeters = Number(km) * 1000;
      if (!radiusMarker) {
        radiusMarker = L.marker(latlng, { icon: radiusIcon, interactive: false }).addTo(map);
      } else {
        radiusMarker.setLatLng(latlng);
      }
      if (!radiusCircle) {
        radiusCircle = L.circle(latlng, {
          radius: radiusMeters,
          color: "#ff922b",
          weight: 2,
          fillColor: "#ffe8cc",
          fillOpacity: 0.25,
          opacity: 0.9,
          interactive: false,
        }).addTo(map);
      } else {
        radiusCircle.setLatLng(latlng);
        radiusCircle.setRadius(radiusMeters);
      }
    }

    function clearRadiusOverlay() {
      if (radiusMarker) {
        map.removeLayer(radiusMarker);
        radiusMarker = null;
      }
      if (radiusCircle) {
        map.removeLayer(radiusCircle);
        radiusCircle = null;
      }
    }

    function updateUserMarker(latlng, accuracy, { pan = false } = {}) {
      // place a marker at users current location with accuracy circle
      const hadLocation = Boolean(state.userLocation);
      state.userLocation = latlng;
      
      // remember this location as the default origin for searches
      if (!state.lastOrigin.nearest) {
        state.lastOrigin.nearest = latlng;
      }
      if (!state.lastOrigin.radius) {
        state.lastOrigin.radius = latlng;
      }
      
      // create or update the user location marker
      if (!userMarker) {
        userMarker = L.marker(latlng, { icon: userIcon, interactive: false }).addTo(map);
      } else {
        userMarker.setLatLng(latlng);
      }
      
      // show accuracy circle around user location if we have that info
      if (accuracy && !Number.isNaN(Number(accuracy))) {
        const radius = Math.max(Number(accuracy), 25);
        if (!userAccuracyCircle) {
          userAccuracyCircle = L.circle(latlng, {
            radius,
            color: "#0d6efd",
            weight: 1,
            fillColor: "#0d6efd",
            fillOpacity: 0.14,
            interactive: false,
          }).addTo(map);
        } else {
          userAccuracyCircle.setLatLng(latlng);
          userAccuracyCircle.setRadius(radius);
        }
      }
      
      // pan map to user location if requested or if this is first time getting location
      if (pan || !hadLocation) {
        map.flyTo(latlng, Math.max(map.getZoom(), 14), { duration: 0.75 });
      }
    }

    function attemptLocateUser({ manual = false } = {}) {
      // try to get users current location from browser geolocation api
      if (!navigator.geolocation) {
        setStatus("Geolocation not supported", "warning");
        return;
      }
      navigator.geolocation.getCurrentPosition(
        (position) => {
          const latlng = L.latLng(position.coords.latitude, position.coords.longitude);
          updateUserMarker(latlng, position.coords.accuracy, { pan: true });
          
          // automatically search for nearby amenities if user clicked locate button or in nearest mode
          if (manual || state.mode === "nearest") {
            if (state.mode === "radius") {
              fetchAmenitiesRadius(latlng);
            } else {
              fetchAmenitiesNearest(latlng);
            }
          } else {
            setStatus("Click the map to search for amenities", "info");
          }
        },
        (error) => {
          setStatus("Unable to get location. Click the map instead.", "warning");
        }
      );
    }

    function focusAmenity(featureId) {
      const layer = amenityLayerIndex.get(String(featureId));
      if (!layer) return;
      const point = layer.getLatLng();
      if (point) {
        map.flyTo(point, Math.max(map.getZoom(), 15), { duration: 0.5 });
      }
      if (layer.getPopup()) {
        layer.openPopup();
      }
    }

    function renderResults(features) {
      resultsList.innerHTML = "";
      if (!features || features.length === 0) {
        resultsList.innerHTML = '<div class="text-muted">No results found.</div>';
        return;
      }

      features.forEach((feature, index) => {
        const card = document.createElement("button");
        card.className = "result-card";

        const props = feature.properties || {};
        const name = props.name || "Unnamed";
        const category = props.category || "amenity";
        const distanceLabel = formatDistance(props.distance);

        card.innerHTML = `
          <span class="result-index">${index + 1}</span>
          <div>
            <div class="result-title">${name}</div>
            <span class="badge bg-secondary">${category}</span>
            ${distanceLabel ? `<span class="badge bg-primary ms-1">${distanceLabel}</span>` : ""}
          </div>
        `;

        card.addEventListener("click", () => focusAmenity(feature.id));
        resultsList.appendChild(card);
      });
    }

    function handleResponse(response) {
      if (!response.ok) {
        return response.json().catch(() => ({})).then(err => {
          const detail = err.detail || "Unable to complete the request.";
          throw new Error(Array.isArray(detail) ? detail.join(" ") : detail);
        });
      }
      return response.json();
    }

    function applyFilters(features) {
      // filter amenities by selected categories and search text on the client side
      let filtered = Array.isArray(features) ? features.slice() : [];

      // filter by category chips if any are selected
      if (state.selectedCategories.size > 0) {
        filtered = filtered.filter(feature => {
          const category = feature?.properties?.category;
          return state.selectedCategories.has(category);
        });
      }

      // filter by search term across name and detail fields
      if (state.searchTerm) {
        filtered = filtered.filter(feature => {
          const props = feature.properties || {};
          const details = extractDetails(feature);
          const haystack = [
            props.name || "",
            details.street || "",
            details.operator || "",
            details.brand || "",
            details.cuisine || "",
            details.note || "",
          ]
            .join(" ")
            .toLowerCase();
          return haystack.includes(state.searchTerm);
        });
      }

      return filtered;
    }

    function updateRangeLabels() {
      radiusValue.textContent = `${Number(radiusInput.value).toFixed(1)} km`;
    }

    function getNearestOrigin() {
      return state.lastOrigin.nearest || state.userLocation;
    }

    function getRadiusOrigin() {
      return state.lastOrigin.radius || state.userLocation;
    }

    function replayActiveSearch() {
      if (state.mode === "nearest") {
        const origin = getNearestOrigin();
        if (origin) {
          fetchAmenitiesNearest(origin, { remember: false });
        }
      } else {
        const origin = getRadiusOrigin();
        if (origin) {
          fetchAmenitiesRadius(origin, { remember: false });
        }
      }
    }

    function syncAmenityLayer(features) {
      amenityLayerIndex.clear();
      amenitiesLayer.clearLayers();
      if (features.length > 0) {
        amenitiesLayer.addData({ type: "FeatureCollection", features });
      }
    }

    function fetchAmenitiesNearest(latlng, { remember = true, subjectLabel = null } = {}) {
      // fetch the nearest 30 amenities from the api and display them
      const limit = 30;
      const url = new URL("/api/amenities/nearest", window.location.origin);
      url.searchParams.set("lat", latlng.lat);
      url.searchParams.set("lng", latlng.lng);
      url.searchParams.set("limit", limit);
      if (state.areaId) {
        url.searchParams.set("area_id", state.areaId);
      }

      clearRadiusOverlay();
      setLoading(true);
      const targetLabel = subjectLabel || `${latlng.lat.toFixed(4)}, ${latlng.lng.toFixed(4)}`;
      setStatus(`Fetching nearest amenities near ${targetLabel}…`);
      
      fetch(url)
        .then(handleResponse)
        .then(fc => {
          // apply client side filters and update map
          const features = applyFilters(fc.features || []);
          syncAmenityLayer(features);
          if (features.length > 0) {
            map.flyTo(latlng, Math.max(map.getZoom(), 14), { duration: 0.75 });
          }
          renderResults(features);
          const label = targetLabel;
          setStatus(`Showing ${features.length} amenities near ${label}.`, "success");
          resultSummary.textContent = `Nearest amenities to ${label}.`;
        })
        .catch(error => setStatus(error.message, "danger", true))
        .finally(() => setLoading(false));
      
      rememberOrigin("nearest", latlng, remember);
    }

    function fetchAmenitiesRadius(latlng, { remember = true, subjectLabel = null } = {}) {
      // fetch amenities and routes within a radius from the api
      const km = radiusInput.value || 1.0;
      const amenitiesUrl = new URL("/api/amenities/radius", window.location.origin);
      amenitiesUrl.searchParams.set("lat", latlng.lat);
      amenitiesUrl.searchParams.set("lng", latlng.lng);
      amenitiesUrl.searchParams.set("km", km);
      if (state.areaId) {
        amenitiesUrl.searchParams.set("area_id", state.areaId);
      }

      const routesUrl = new URL("/api/routes/radius", window.location.origin);
      routesUrl.searchParams.set("lat", latlng.lat);
      routesUrl.searchParams.set("lng", latlng.lng);
      routesUrl.searchParams.set("km", km);

      // show the radius circle on map
      updateRadiusOverlay(latlng, km);
      setLoading(true);
      const targetLabel = subjectLabel || `${latlng.lat.toFixed(4)}, ${latlng.lng.toFixed(4)}`;
      setStatus(`Searching within ${km} km of ${targetLabel}…`);
      
      // fetch both amenities and routes in parallel
      Promise.all([
        fetch(amenitiesUrl).then(handleResponse),
        fetch(routesUrl).then(handleResponse)
      ])
        .then(([amenitiesFC, routesFC]) => {
          // filter and display amenities
          const features = applyFilters(amenitiesFC.features || []);
          syncAmenityLayer(features);
          
          // add routes to map
          routesLayer.clearLayers();
          if (routesFC.features && routesFC.features.length > 0) {
            routesLayer.addData(routesFC);
          }
          
          if (features.length > 0) {
            map.flyTo(latlng, Math.max(map.getZoom(), 14), { duration: 0.75 });
          }
          renderResults(features);
          const label = targetLabel;
          setStatus(`Found ${features.length} amenities and ${routesFC.features?.length || 0} routes within ${km} km.`, "success");
          resultSummary.textContent = `Amenities within ${km} km of ${label}.`;
        })
        .catch(error => setStatus(error.message, "danger", true))
        .finally(() => setLoading(false));
      
      rememberOrigin("radius", latlng, remember);
    }

    function fetchAreas(populateOnly = false) {
      return fetch("/api/areas/")
        .then(handleResponse)
        .then(fc => {
          areasLayer.clearLayers();
          if (fc.features && fc.features.length > 0) {
            areasLayer.addData(fc);
            areaSelect.innerHTML = '<option value="">Select an area outline</option>';
            fc.features.forEach(feature => {
              const option = document.createElement("option");
              const id = feature.id || feature.properties.id || feature.properties.pk;
              option.value = id;
              option.textContent = feature.properties.name || `Area ${id}`;
              areaSelect.appendChild(option);
            });
            if (!populateOnly) {
              map.fitBounds(areasLayer.getBounds(), { padding: [30, 30] });
              setStatus(`Loaded ${fc.features.length} area polygon${fc.features.length > 1 ? "s" : ""}.`, "success");
            }
          } else {
            setStatus("No areas available yet.", "warning");
          }
          return fc;
        })
        .catch(error => {
          setStatus(error.message, "danger", true);
        });
    }

    function fetchRoutesIntersecting(areaId) {
      const url = new URL("/api/routes/intersecting", window.location.origin);
      url.searchParams.set("area_id", areaId);
      setStatus("Fetching intersecting routes…");
      fetch(url)
        .then(handleResponse)
        .then(fc => {
          routesLayer.clearLayers();
          if (fc.features && fc.features.length > 0) {
            routesLayer.addData(fc);
            setStatus(`Highlighted ${fc.features.length} intersecting route${fc.features.length > 1 ? "s" : ""}.`, "success");
          } else {
            setStatus("No routes intersect this area.", "warning");
          }
        })
        .catch(error => setStatus(error.message, "danger", true));
    }

    function setMode(newMode) {
      state.mode = newMode;
      radiusSection.classList.toggle("d-none", newMode !== "radius");
      map.getContainer().style.cursor = newMode === "radius" ? "crosshair" : "";
      const hint = newMode === "nearest"
        ? "Nearest mode — click the map to list the closest amenities."
        : "Radius mode — each map click searches within the chosen distance.";
      setStatus(hint, "info");
      if (newMode !== "radius") {
        clearRadiusOverlay();
      }
      replayActiveSearch();
    }

    map.on("click", (event) => {
      const { latlng } = event;
      if (state.mode === "radius") {
        fetchAmenitiesRadius(latlng);
      } else {
        fetchAmenitiesNearest(latlng);
      }
    });

    locateButton.addEventListener("click", () => {
      setStatus("Locating you…");
      attemptLocateUser({ manual: true });
    });

    document.getElementById("resetView").addEventListener("click", () => {
      state.areaId = null;
      state.lastOrigin.radius = null;
      if (state.userLocation) {
        state.lastOrigin.nearest = state.userLocation;
      } else {
        state.lastOrigin.nearest = null;
      }
      clearRadiusOverlay();
      amenityLayerIndex.clear();
      amenitiesLayer.clearLayers();
      routesLayer.clearLayers();
      areaSelect.value = "";
      if (areasLayer.getLayers().length > 0) {
        map.fitBounds(areasLayer.getBounds(), { padding: [30, 30] });
      } else {
        map.setView([53.3498, -6.2603], 13);
      }
      resultsList.innerHTML = "";
      resultSummary.textContent = "Click the map to begin exploring.";
      setStatus("View reset. Click the map to explore again.", "secondary");
    });

    document.getElementById("btnClearRoutes").addEventListener("click", () => {
      routesLayer.clearLayers();
      setStatus("Cleared route overlays.");
    });

    modeButtons.forEach(button => {
      button.addEventListener("click", (event) => {
        modeButtons.forEach(btn => btn.classList.remove("active"));
        event.currentTarget.classList.add("active");
        setMode(event.currentTarget.dataset.mode);
      });
    });

    categoryChips.forEach(chip => {
      chip.addEventListener("click", () => {
        const category = chip.dataset.category;
        if (category === "all") {
          state.selectedCategories.clear();
        } else {
          if (state.selectedCategories.has(category)) {
            state.selectedCategories.delete(category);
          } else {
            state.selectedCategories.add(category);
          }
        }
        updateCategoryChipsUI();
        replayActiveSearch();
      });
    });

    searchInput.addEventListener("input", () => {
      if (searchDebounce) {
        clearTimeout(searchDebounce);
      }
      searchDebounce = setTimeout(() => {
        state.searchTerm = searchInput.value.trim().toLowerCase();
        replayActiveSearch();
      }, 200);
    });

    areaSelect.addEventListener("change", (event) => {
      const areaId = event.target.value;
      state.areaId = areaId || null;
      if (!areaId) {
        routesLayer.clearLayers();
        setStatus("Area selection cleared.", "secondary");
        replayActiveSearch();
        if (amenitiesLayer.getLayers().length) {
          map.fitBounds(amenitiesLayer.getBounds(), { padding: [30, 30] });
        }
        return;
      }
      const matchingLayer = areasLayer.getLayers().find(layer => {
        const feature = layer.feature || {};
        const id = feature.id || feature.properties?.id || feature.properties?.pk;
        return String(id) === areaId;
      });
      if (matchingLayer) {
        map.fitBounds(matchingLayer.getBounds(), { padding: [50, 50] });
        fetchRoutesIntersecting(areaId);
        setStatus("Area selected. Routes highlighted. Click the map to search for amenities.", "success");
      } else {
        setStatus("Could not find area boundaries.", "warning");
      }
    });

    radiusInput.addEventListener("input", () => {
      updateRangeLabels();
      if (state.mode === "radius") {
        replayActiveSearch();
      }
    });

    updateCategoryChipsUI();
    fetchAreas(true);
    updateRangeLabels();
    setMode(state.mode);
    attemptLocateUser();
  }

  initMap();
});
</script>
{% endblock %}
